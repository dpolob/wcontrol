# precipitacion acumulada DONE!
# imputacion de resultados para NaNs (tengo muchos) DONE!
#poner mape
# def mape(actual, pred): 
#     actual, pred = np.array(actual), np.array(pred)
#     return np.mean(np.abs((actual - pred) / actual)) * 100

# corregir maxMSE y maxL1 porque no solo sacaban en mÃ¡ximo entre todas las series. Ahora se hace media
# MAX(MEAN(error(reduction=none)))

# Quitar las variables de tiempo relativas al dia de la semana (no hay estacionalidad) por lo que no pintan nada

Dataset convendria serparar la etiquetaT y etiquetaF
#seq2seq No hardcoding de la salida del decoder (N,1) -> (N, Fout)


 Revisar esto en trainer._loss_batch       
        if pass_y:
            y_pred = self.model(Xt, X, Yt, Y, P, teacher)
        else:
            y_pred = self.model(Xt, X, Yt, Y, P, teacher)

# tqdm en escalado del generarvariablesZmodel

Cambiar nombre a modules (es mu feo)

Quitar todo lo de teacher forcing y duplicate teacher forcing


Crear un wrapper que integre la creacion de decoder y encoder solo pasando (Ft, Ff, Fnwp, Fout)
Algunos argumentos de entrada de  model = module.EncoderDecoderWrapper(encoder=encoder,
                                    decoder_cell=decoder,
                                    output_size=OUTPUT_SIZE,
                                    output_sequence_len=FUTURO,
                                    teacher_forcing=cfg.zmodel.model.teacher_forcing,
                                    duplicate_teaching=cfg.zmodel.model.duplicate_teaching,
                                    device=device)
se pueden obtener del encoder y el decoder

# def quitar_nans(df: pd.DataFrame=None) -> pd.DataFrame:
#     # chequear que las variables ciclicas de fecha estan y si no es asi crearlas
#     if set(['dia_sin', 'dia_cos', 'mes_sin', 'mes_cos']).issubset(df.columns):
#         tqdm.write(f"Las variables ciclicas estan creadas")
#         return None
    
#     df['fecha'] = df.index
#     df['dia_sin'], df['dia_cos'], df['mes_sin'], df['mes_cos'], df['hora_sin'], df['hora_cos'] = cyclic(df['fecha'])
#     df.drop(columns=['fecha'], inplace=True)
#     tqdm.write(f"{df.isna().sum().sum()}", end='')
#     if not check_no_nan(df):
#         imp_mean = IterativeImputer(random_state=0)
#         idf=imp_mean.fit_transform(df)
#         idf = pd.DataFrame(idf, columns=df.columns)
#         df['temperatura'] = idf['temperatura'].values
#         df['hr'] = idf['hr'].values
#         df['precipitacion'] = idf['precipitacion'].values
#         del idf
#         tqdm.write(" -> " + str(df.isna().sum().sum()), end='')
#         tqdm.write("\t" + OK)
#         if not check_no_nan(df):
#             tqdm.write("Quedan NaNs en el dataset. Por favor compruebe")
#             return None
#     df.drop(columns=['dia_sin', 'dia_cos', 'mes_sin','mes_cos', 'hora_sin', 'hora_cos'], inplace=True)
#     return df