# precipitacion acumulada DONE!
# imputacion de resultados para NaNs (tengo muchos) DONE!
#poner mape
# def mape(actual, pred): 
#     actual, pred = np.array(actual), np.array(pred)
#     return np.mean(np.abs((actual - pred) / actual)) * 100

# corregir maxMSE y maxL1 porque no solo sacaban en mÃ¡ximo entre todas las series. Ahora se hace media
# MAX(MEAN(error(reduction=none)))

# Quitar las variables de tiempo relativas al dia de la semana (no hay estacionalidad) por lo que no pintan nada

#seq2seq No hardcoding de la salida del decoder (N,1) -> (N, Fout)


 Revisar esto en trainer._loss_batch       
        if pass_y:
            y_pred = self.model(Xt, X, Yt, Y, P, teacher)
        else:
            y_pred = self.model(Xt, X, Yt, Y, P, teacher)

# tqdm en escalado del generarvariablesZmodel

Cambiar nombre a modules (es mu feo)

Quitar todo lo de teacher forcing y duplicate teacher forcing

Guardar hiperparametros con el modelo, para no tener que crear los Encoders y Decoders en el predict

Crear un wrapper que integre la creacion de decoder y encoder solo pasando (Ft, Ff, Fnwp, Fout)
Algunos argumentos de entrada de  model = module.EncoderDecoderWrapper(encoder=encoder,
                                    decoder_cell=decoder,
                                    output_size=OUTPUT_SIZE,
                                    output_sequence_len=FUTURO,
                                    teacher_forcing=cfg.zmodel.model.teacher_forcing,
                                    duplicate_teaching=cfg.zmodel.model.duplicate_teaching,
                                    device=device)
se pueden obtener del encoder y el decoder


La salida X en el dataset no vale para nada si funciona 3salidas y aun asi creo que tampoco