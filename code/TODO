# precipitacion acumulada DONE!
# imputacion de resultados para NaNs (tengo muchos) DONE!
#poner mape
# def mape(actual, pred): 
#     actual, pred = np.array(actual), np.array(pred)
#     return np.mean(np.abs((actual - pred) / actual)) * 100

# corregir maxMSE y maxL1 porque no solo sacaban en mÃ¡ximo entre todas las series. Ahora se hace media
# MAX(MEAN(error(reduction=none)))

# Quitar las variables de tiempo relativas al dia de la semana (no hay estacionalidad) por lo que no pintan nada


seq2seq No hardcoding de la salida del decoder (N,1) -> (N, Fout)

# tqdm en escalado del generarvariablesZmodel

Cambiar nombre a modules (es mu feo)



# def quitar_nans(df: pd.DataFrame=None) -> pd.DataFrame:
#     # chequear que las variables ciclicas de fecha estan y si no es asi crearlas
#     if set(['dia_sin', 'dia_cos', 'mes_sin', 'mes_cos']).issubset(df.columns):
#         tqdm.write(f"Las variables ciclicas estan creadas")
#         return None
    
#     df['fecha'] = df.index
#     df['dia_sin'], df['dia_cos'], df['mes_sin'], df['mes_cos'], df['hora_sin'], df['hora_cos'] = cyclic(df['fecha'])
#     df.drop(columns=['fecha'], inplace=True)
#     tqdm.write(f"{df.isna().sum().sum()}", end='')
#     if not check_no_nan(df):
#         imp_mean = IterativeImputer(random_state=0)
#         idf=imp_mean.fit_transform(df)
#         idf = pd.DataFrame(idf, columns=df.columns)
#         df['temperatura'] = idf['temperatura'].values
#         df['hr'] = idf['hr'].values
#         df['precipitacion'] = idf['precipitacion'].values
#         del idf
#         tqdm.write(" -> " + str(df.isna().sum().sum()), end='')
#         tqdm.write("\t" + OK)
#         if not check_no_nan(df):
#             tqdm.write("Quedan NaNs en el dataset. Por favor compruebe")
#             return None
#     df.drop(columns=['dia_sin', 'dia_cos', 'mes_sin','mes_cos', 'hora_sin', 'hora_cos'], inplace=True)
#     return df